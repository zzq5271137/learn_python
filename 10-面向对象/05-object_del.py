"""
析构函数和引用计数
"""

import sys

"""
析构函数:
Python中的类也有析构函数, 即__del__()方法, 只要对象在内存中即将被销毁的时候, 就会调用这个方法;
(相对应的, 构造方法__init__()是在对象被创建完毕, 即分配好内存空间后, 被自动调用的, 它主要是去做一些初始化工作, 之前讲过)
"""


class Person(object):
    def __init__(self, name):
        self.name = name

    def __del__(self):  # 析构函数, 我们经常在析构函数中做一些收尾工作, 比如流的关闭操作(例如文件的close())
        print("%s: 析构函数被调用了" % self.name)


p1 = Person('zzq1')

# 执行这行代码时, 会清除p1对这个Person对象的引用, 然后由于本来就只有一个变量指向这个对象,
# 所以当清除p1对这个对象的引用后, 该对象的引用计数(引用计数详见下方)会变为0, 所以Python会回收这块内存空间(销毁这个对象),
# 所以就会自动调用Person类的__del__()方法; 或者当代码执行结束, 销毁对象回收内存空间时, 也会自动调用__del__()方法;
del p1

print("###################################################################################")

"""
引用计数:
Python中的对象是有引用计数的, 每个对象都对应着一块内存空间, 当没有任何指针指向它(没有任何引用)的时候,
这块内存空间就会被回收(有点像Java的内存回收机制);
可以使用sys.getrefcount()来获取一个对象的引用计数;
"""
p2 = Person('zzq2')
print(sys.getrefcount(p2))  # 这里会打印出2, 因为sys.getrefcount()函数中有一个变量引用到这个对象了, 加上p2, 所以是两个
p3 = p2
print(sys.getrefcount(p2))
del p2
print(sys.getrefcount(p3))
